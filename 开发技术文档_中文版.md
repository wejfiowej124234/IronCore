# ğŸ› ï¸ Rust åŒºå—é“¾å®‰å…¨é’±åŒ… - å¼€å‘æŠ€æœ¯æ–‡æ¡£

> **ç‰ˆæœ¬**: v0.3.0  
> **æ›´æ–°æ—¥æœŸ**: 2024-11-13  
> **æ–‡æ¡£ç±»å‹**: å¼€å‘æŒ‡å—ä¸æŠ€æœ¯ç»†èŠ‚

---

## ğŸ“‹ ç›®å½•

1. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
2. [å¼€å‘ç¯å¢ƒæ­å»º](#å¼€å‘ç¯å¢ƒæ­å»º)
3. [æ ¸å¿ƒæŠ€æœ¯å®ç°](#æ ¸å¿ƒæŠ€æœ¯å®ç°)
4. [API å¼€å‘æŒ‡å—](#api-å¼€å‘æŒ‡å—)
5. [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
6. [å®‰å…¨æœ€ä½³å®è·µ](#å®‰å…¨æœ€ä½³å®è·µ)
7. [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)
8. [éƒ¨ç½²æŒ‡å—](#éƒ¨ç½²æŒ‡å—)
9. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
10. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## å¿«é€Ÿå¼€å§‹

### 5 åˆ†é’Ÿå¿«é€Ÿå¯åŠ¨

```bash
# 1. å…‹éš†é¡¹ç›®
git clone https://github.com/DarkCrab-Rust/Rust-Blockchain-Secure-Wallet.git
cd Rust-Blockchain-Secure-Wallet

# 2. é…ç½®ç¯å¢ƒå˜é‡
cp env.example.txt .env
# ç¼–è¾‘ .env æ–‡ä»¶ï¼Œè®¾ç½®å¿…è¦çš„ç¯å¢ƒå˜é‡

# 3. æ„å»ºé¡¹ç›®
cargo build --release

# 4. è¿è¡Œæ•°æ®åº“è¿ç§»
sqlite3 users.db < migrations/users/001_create_users_table.sql

# 5. å¯åŠ¨æœåŠ¡å™¨
cargo run --release
# æœåŠ¡å™¨å°†åœ¨ http://localhost:8888 å¯åŠ¨
```

### å¼€å‘æ¨¡å¼å¯åŠ¨

```bash
# ä½¿ç”¨å¼€å‘è„šæœ¬ (åŒ…å«æµ‹è¯•ç¯å¢ƒå˜é‡)
./start-for-frontend.sh  # Linux/Mac
# æˆ–
.\start-for-frontend.ps1  # Windows
```

---

## å¼€å‘ç¯å¢ƒæ­å»º

### 1. å¿…éœ€å·¥å…·

| å·¥å…· | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|
| **Rust** | 1.75+ | ç¼–ç¨‹è¯­è¨€ |
| **Cargo** | 1.75+ | æ„å»ºå·¥å…· |
| **SQLite** | 3.x | æ•°æ®åº“ |
| **Git** | 2.x | ç‰ˆæœ¬æ§åˆ¶ |

```bash
# å®‰è£… Rust (rustup)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# éªŒè¯å®‰è£…
rustc --version
cargo --version

# å®‰è£… SQLite
# Ubuntu/Debian
sudo apt-get install sqlite3 libsqlite3-dev

# macOS
brew install sqlite

# Windows (ä¸‹è½½äºŒè¿›åˆ¶æ–‡ä»¶)
# https://www.sqlite.org/download.html
```

### 2. æ¨èçš„å¼€å‘å·¥å…·

```bash
# ä»£ç æ ¼å¼åŒ–å·¥å…·
rustup component add rustfmt

# ä»£ç æ£€æŸ¥å·¥å…·
rustup component add clippy

# æµ‹è¯•è¦†ç›–ç‡å·¥å…·
cargo install cargo-tarpaulin

# ä¾èµ–å®¡è®¡å·¥å…·
cargo install cargo-deny

# è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ
cargo doc --open
```

### 3. IDE é…ç½®

#### VS Code

```json
// .vscode/settings.json
{
  "rust-analyzer.cargo.features": ["all-chains"],
  "rust-analyzer.checkOnSave.command": "clippy",
  "editor.formatOnSave": true,
  "rust-analyzer.inlayHints.enable": true
}
```

#### IntelliJ IDEA / RustRover

```
å®‰è£…æ’ä»¶: Rust Plugin
é…ç½®: Settings > Languages & Frameworks > Rust
å¯ç”¨: External Linter (Clippy)
```

### 4. ç¯å¢ƒå˜é‡é…ç½®

åˆ›å»º `.env` æ–‡ä»¶ï¼š

```bash
# .env
# ==================== æ•°æ®åº“é…ç½® ====================
DATABASE_URL=sqlite://./wallets.db
USERS_DATABASE_URL=sqlite://./users.db

# ==================== å®‰å…¨å¯†é’¥ ====================
# âš ï¸ ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä¿®æ”¹è¿™äº›å¯†é’¥ï¼

# JWT å¯†é’¥ (ç”¨äºç­¾å Token)
JWT_SECRET=your-secret-key-at-least-32-bytes-long

# é’±åŒ…åŠ å¯†å¯†é’¥ (32 å­—èŠ‚ï¼ŒBase64 ç¼–ç )
# ç”Ÿæˆæ–¹æ³•: openssl rand -base64 32
WALLET_ENC_KEY=RDU3il552PpK2r0VsYY4UuLClwVDlL2XQHSPFRdKrjA=

# API å¯†é’¥ (å¯é€‰ï¼Œç”¨äºç¬¬ä¸‰æ–¹é›†æˆ)
API_KEY=your-api-key-for-third-party-integration

# ==================== åŒºå—é“¾ RPC é…ç½® ====================
# Ethereum Mainnet
ETHEREUM_RPC=https://eth-mainnet.alchemyapi.io/v2/YOUR-API-KEY

# Ethereum Sepolia Testnet
SEPOLIA_RPC=https://sepolia.drpc.org

# Polygon Mainnet
POLYGON_RPC=https://polygon-rpc.com

# BSC Mainnet
BSC_RPC=https://bsc-dataseed.binance.org/

# BSC Testnet
BSC_TESTNET_RPC=https://data-seed-prebsc-1-s1.binance.org:8545

# ==================== CORS é…ç½® ====================
# å…è®¸çš„å‰ç«¯åŸŸå (é€—å·åˆ†éš”å¤šä¸ªåŸŸå)
CORS_ALLOW_ORIGIN=http://localhost:3000,http://localhost:5173

# ==================== æ—¥å¿—é…ç½® ====================
RUST_LOG=info,hyper=warn,h2=warn,tower=info

# ==================== å¼€å‘æ¨¡å¼æ ‡å¿— ====================
# ä»…åœ¨å¼€å‘ç¯å¢ƒä½¿ç”¨
DEV_MODE=1
```

---

## æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. é’±åŒ…åˆ›å»ºæµç¨‹

#### å®Œæ•´å®ç° (éæ‰˜ç®¡æ¨¡å¼)

```rust
// src/core/wallet_manager/lifecycle.rs

pub async fn create_wallet(
    &self,
    name: &str,
    password: &str,
    quantum_safe: bool,
) -> Result<(), WalletError> {
    // ==================== æ­¥éª¤ 1: éªŒè¯é’±åŒ…åç§° ====================
    {
        let wallets = self.wallets.read();
        if wallets.contains_key(name) {
            return Err(WalletError::ValidationError(
                format!("Wallet '{}' already exists", name)
            ));
        }
    }

    // ==================== æ­¥éª¤ 2: ç”Ÿæˆ BIP39 åŠ©è®°è¯ ====================
    use bip39::{Language, Mnemonic};
    use rand::RngCore;
    
    // ç”Ÿæˆ 32 å­—èŠ‚éšæœºç†µ (256 bits)
    let mut entropy = [0u8; 32];
    rand::rngs::OsRng.fill_bytes(&mut entropy);
    
    // ä»ç†µç”ŸæˆåŠ©è®°è¯ (24 ä¸ªå•è¯)
    let mnemonic = Mnemonic::from_entropy_in(Language::English, &entropy)
        .map_err(|e| WalletError::MnemonicError(format!("ç”ŸæˆåŠ©è®°è¯å¤±è´¥: {}", e)))?;
    
    info!("âœ… ç”ŸæˆåŠ©è®°è¯: 24 ä¸ªå•è¯");

    // ==================== æ­¥éª¤ 3: ä»åŠ©è®°è¯æ´¾ç”Ÿç§å­ ====================
    // BIP39: åŠ©è®°è¯ â†’ 512-bit ç§å­
    let seed_bytes = mnemonic.to_seed("");  // ç©ºå¯†ç çŸ­è¯­
    let mut master_key = [0u8; 32];
    master_key.copy_from_slice(&seed_bytes[..32]);
    
    info!("âœ… ä»åŠ©è®°è¯æ´¾ç”Ÿä¸»å¯†é’¥");

    // ==================== æ­¥éª¤ 4: ç”Ÿæˆç›å€¼ ====================
    let mut salt = [0u8; 32];
    rand::rngs::OsRng.fill_bytes(&mut salt);
    
    // ==================== æ­¥éª¤ 5: ä½¿ç”¨ PBKDF2 ä»å¯†ç æ´¾ç”ŸåŠ å¯†å¯†é’¥ ====================
    use pbkdf2::pbkdf2_hmac;
    use sha2::Sha256;
    
    let iterations = self.config.security.pbkdf2_iterations; // é»˜è®¤ 100,000
    let mut encryption_key = [0u8; 32];
    pbkdf2_hmac::<Sha256>(
        password.as_bytes(),
        &salt,
        iterations,
        &mut encryption_key,
    );
    
    info!("âœ… PBKDF2 å¯†é’¥æ´¾ç”Ÿå®Œæˆ (è¿­ä»£æ¬¡æ•°: {})", iterations);

    // ==================== æ­¥éª¤ 6: ä½¿ç”¨ AES-256-GCM åŠ å¯†ä¸»å¯†é’¥ ====================
    use aes_gcm::{Aes256Gcm, KeyInit, aead::Aead};
    
    let cipher = Aes256Gcm::new_from_slice(&encryption_key)
        .map_err(|_| WalletError::CryptoError("åˆ›å»º AES å¯†ç å™¨å¤±è´¥".into()))?;
    
    // ç”Ÿæˆéšæœº nonce (12 å­—èŠ‚)
    let mut nonce_bytes = [0u8; 12];
    rand::rngs::OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = aes_gcm::Nonce::from(nonce_bytes);
    
    // åŠ å¯†ä¸»å¯†é’¥
    let encrypted_master_key = cipher.encrypt(&nonce, master_key.as_ref())
        .map_err(|_| WalletError::CryptoError("åŠ å¯†ä¸»å¯†é’¥å¤±è´¥".into()))?;
    
    info!("âœ… ä¸»å¯†é’¥åŠ å¯†å®Œæˆ (é•¿åº¦: {} å­—èŠ‚)", encrypted_master_key.len());

    // ==================== æ­¥éª¤ 7: åˆ›å»ºé’±åŒ…æ•°æ®ç»“æ„ ====================
    use chrono::Utc;
    use uuid::Uuid;
    
    let wallet_info = crate::core::wallet_info::WalletInfo {
        id: Uuid::new_v4(),
        name: name.to_string(),
        created_at: Utc::now(),
        quantum_safe,
        multi_sig_threshold: 1,
        networks: vec!["eth".to_string(), "btc".to_string()],
    };
    
    let wallet_data = crate::core::wallet_info::SecureWalletData {
        info: wallet_info,
        encrypted_master_key,
        shamir_shares: Vec::new(),
        salt: salt.to_vec(),
        nonce: nonce_bytes.to_vec(),
        schema_version: 2,
        kek_id: None,
    };

    // ==================== æ­¥éª¤ 8: å­˜å‚¨åˆ°å†…å­˜ ====================
    {
        let mut wallets = self.wallets.write();
        wallets.insert(name.to_string(), wallet_data);
    }

    // ==================== æ­¥éª¤ 9: æ¸…ç†æ•æ„Ÿæ•°æ® ====================
    use zeroize::Zeroize;
    master_key.zeroize();
    encryption_key.zeroize();
    
    info!("âœ… é’±åŒ… '{}' åˆ›å»ºæˆåŠŸ", name);
    Ok(())
}
```

#### BIP44 åœ°å€æ´¾ç”Ÿ

```rust
// src/core/wallet_manager/derivation.rs

/// BIP44 æ´¾ç”Ÿè·¯å¾„æ ¼å¼: m/44'/coin_type'/account'/change/address_index
pub async fn derive_address(
    &self,
    wallet_name: &str,
    coin_type: u32,  // ETH=60, BTC=0
    account: u32,     // é€šå¸¸ä¸º 0
    change: u32,      // 0=å¤–éƒ¨åœ°å€, 1=æ‰¾é›¶åœ°å€
    index: u32,       // åœ°å€ç´¢å¼•
) -> Result<String, WalletError> {
    // 1. è·å–é’±åŒ…æ•°æ®
    let wallet_data = self.get_wallet_data(wallet_name)?;
    
    // 2. è§£å¯†ä¸»å¯†é’¥
    let master_key = self.decrypt_master_key(&wallet_data, password)?;
    
    // 3. BIP32 å¯†é’¥æ´¾ç”Ÿ
    use coins_bip32::prelude::*;
    
    let path = format!("m/44'/{}'/{}'/{}/{}", coin_type, account, change, index);
    let derived_key = master_key.derive_path(&path)?;
    
    // 4. æ ¹æ®å¸ç§ç”Ÿæˆåœ°å€
    let address = match coin_type {
        60 => {
            // Ethereum: ECDSA secp256k1 â†’ Keccak256 â†’ å–å 20 å­—èŠ‚
            use sha3::{Keccak256, Digest};
            use secp256k1::{PublicKey, Secp256k1};
            
            let secp = Secp256k1::new();
            let secret_key = secp256k1::SecretKey::from_slice(&derived_key.to_bytes())?;
            let public_key = PublicKey::from_secret_key(&secp, &secret_key);
            
            // å…¬é’¥åºåˆ—åŒ– (æœªå‹ç¼©æ ¼å¼ï¼Œå»æ‰å‰ç¼€ 0x04)
            let pub_bytes = &public_key.serialize_uncompressed()[1..];
            
            // Keccak256 å“ˆå¸Œ
            let mut hasher = Keccak256::new();
            hasher.update(pub_bytes);
            let hash = hasher.finalize();
            
            // å–å 20 å­—èŠ‚ä½œä¸ºåœ°å€
            format!("0x{}", hex::encode(&hash[12..]))
        }
        0 => {
            // Bitcoin: ä½¿ç”¨ bitcoin åº“ç”Ÿæˆåœ°å€
            // å®ç°ç•¥
            todo!("Bitcoin address derivation")
        }
        _ => return Err(WalletError::NotImplemented(format!("Coin type {} not supported", coin_type))),
    };
    
    Ok(address)
}
```

### 2. äº¤æ˜“ç­¾åæµç¨‹

#### Ethereum äº¤æ˜“ç­¾å (EIP-1559)

```rust
// src/core/wallet_manager/signing.rs

pub async fn sign_eip1559_transaction(
    &self,
    wallet_name: &str,
    to_address: &str,
    value: &str,
    max_fee_per_gas: Option<String>,
    max_priority_fee_per_gas: Option<String>,
    data: Option<Vec<u8>>,
) -> Result<Vec<u8>, WalletError> {
    use ethers::types::{Address, U256, Eip1559TransactionRequest};
    use ethers::signers::{LocalWallet, Signer};
    
    // ==================== æ­¥éª¤ 1: è·å–ç§é’¥ ====================
    let private_key_bytes = self.get_private_key(wallet_name).await?;
    
    // ==================== æ­¥éª¤ 2: åˆ›å»ºé’±åŒ… ====================
    let wallet = LocalWallet::from_bytes(&private_key_bytes)?
        .with_chain_id(self.chain_id);
    
    // ==================== æ­¥éª¤ 3: è§£æå‚æ•° ====================
    let to: Address = to_address.parse()
        .map_err(|_| WalletError::InvalidAddress(to_address.to_string()))?;
    
    let value: U256 = U256::from_dec_str(value)
        .map_err(|_| WalletError::InvalidAmount(value.to_string()))?;
    
    // ==================== æ­¥éª¤ 4: è·å–å½“å‰ Gas ä»·æ ¼ ====================
    let (max_fee, max_priority_fee) = if max_fee_per_gas.is_none() {
        // è‡ªåŠ¨ä¼°ç®— Gas ä»·æ ¼
        let base_fee = self.ethereum_client.get_base_fee().await?;
        let priority_fee = U256::from(2_000_000_000u64); // 2 Gwei
        
        let max_fee = base_fee * 2 + priority_fee;
        (max_fee, priority_fee)
    } else {
        (
            U256::from_dec_str(&max_fee_per_gas.unwrap())?,
            U256::from_dec_str(&max_priority_fee_per_gas.unwrap())?,
        )
    };
    
    // ==================== æ­¥éª¤ 5: è·å– Nonce ====================
    let nonce = self.get_nonce(&wallet.address().to_string()).await?;
    
    // ==================== æ­¥éª¤ 6: æ„å»ºäº¤æ˜“ ====================
    let tx = Eip1559TransactionRequest {
        to: Some(to.into()),
        value: Some(value),
        max_fee_per_gas: Some(max_fee),
        max_priority_fee_per_gas: Some(max_priority_fee),
        nonce: Some(nonce.into()),
        data: data.map(|d| d.into()),
        chain_id: Some(self.chain_id.into()),
        ..Default::default()
    };
    
    // ==================== æ­¥éª¤ 7: ç­¾åäº¤æ˜“ ====================
    let signature = wallet.sign_transaction(&tx).await
        .map_err(|e| WalletError::SigningFailed(e.to_string()))?;
    
    // ==================== æ­¥éª¤ 8: åºåˆ—åŒ–äº¤æ˜“ ====================
    let signed_tx = tx.rlp_signed(&signature);
    
    Ok(signed_tx.to_vec())
}
```

### 3. è·¨é“¾æ¡¥æ¥å®ç°

```rust
// src/blockchain/bridge/lifi.rs

pub struct LiFiBridge {
    api_url: String,
    http_client: reqwest::Client,
}

impl LiFiBridge {
    pub fn new() -> Self {
        Self {
            api_url: "https://li.quest/v1".to_string(),
            http_client: reqwest::Client::new(),
        }
    }
    
    /// æŸ¥è¯¢è·¨é“¾è·¯ç”±
    pub async fn get_quote(
        &self,
        from_chain: &str,
        to_chain: &str,
        from_token: &str,
        to_token: &str,
        amount: &str,
    ) -> Result<BridgeQuote> {
        let params = serde_json::json!({
            "fromChain": from_chain,
            "toChain": to_chain,
            "fromToken": from_token,
            "toToken": to_token,
            "fromAmount": amount,
        });
        
        let response = self.http_client
            .get(format!("{}/quote", self.api_url))
            .json(&params)
            .send()
            .await?;
        
        let quote: BridgeQuote = response.json().await?;
        Ok(quote)
    }
    
    /// æ‰§è¡Œè·¨é“¾è½¬è´¦
    pub async fn execute_bridge(
        &self,
        route: &BridgeRoute,
        from_address: &str,
        private_key: &[u8],
    ) -> Result<String> {
        // 1. æ„å»ºäº¤æ˜“
        let tx_data = self.build_bridge_transaction(route, from_address)?;
        
        // 2. ç­¾åäº¤æ˜“
        let signed_tx = self.sign_transaction(tx_data, private_key)?;
        
        // 3. å‘é€äº¤æ˜“
        let tx_hash = self.send_raw_transaction(&signed_tx).await?;
        
        // 4. ç­‰å¾…ç¡®è®¤
        self.wait_for_confirmation(&tx_hash).await?;
        
        Ok(tx_hash)
    }
}
```

---

## API å¼€å‘æŒ‡å—

### 1. åˆ›å»ºæ–°çš„ API ç«¯ç‚¹

#### æ­¥éª¤ 1: å®šä¹‰è¯·æ±‚/å“åº”ç±»å‹

```rust
// src/api/types.rs

use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
pub struct SendTransactionRequest {
    pub wallet_name: String,
    pub to_address: String,
    pub amount: String,
    pub network: String,  // "ethereum", "polygon", "bsc"
    
    #[serde(default)]
    pub max_fee_per_gas: Option<String>,
    
    #[serde(default)]
    pub max_priority_fee_per_gas: Option<String>,
    
    #[serde(default)]
    pub data: Option<String>,  // Hex-encoded contract call data
}

#[derive(Debug, Serialize)]
pub struct SendTransactionResponse {
    pub tx_hash: String,
    pub network: String,
    pub status: String,  // "pending", "confirmed", "failed"
    pub explorer_url: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
    pub code: String,
    pub details: Option<serde_json::Value>,
}
```

#### æ­¥éª¤ 2: å®ç°å¤„ç†å™¨å‡½æ•°

```rust
// src/api/handlers/transaction.rs

use axum::{
    extract::{Path, State},
    http::{HeaderMap, StatusCode},
    response::Json,
};
use std::sync::Arc;
use tracing::{info, error};

use crate::api::middleware::extract_user::{extract_user_id_from_token, verify_wallet_ownership};
use crate::api::server::WalletServer;
use crate::api::types::*;
use crate::api::validators::*;

pub async fn send_transaction(
    State(state): State<Arc<WalletServer>>,
    headers: HeaderMap,
    Json(payload): Json<SendTransactionRequest>,
) -> Result<Json<SendTransactionResponse>, (StatusCode, Json<ErrorResponse>)> {
    // ==================== æ­¥éª¤ 1: éªŒè¯ç”¨æˆ·èº«ä»½ ====================
    let user_id = extract_user_id_from_token(&headers, &state).await
        .map_err(|e| (
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: format!("èº«ä»½éªŒè¯å¤±è´¥: {}", e),
                code: "AUTH_FAILED".to_string(),
                details: None,
            }),
        ))?;
    
    info!("ç”¨æˆ· {} è¯·æ±‚å‘é€äº¤æ˜“", user_id);
    
    // ==================== æ­¥éª¤ 2: éªŒè¯é’±åŒ…æ‰€æœ‰æƒ ====================
    verify_wallet_ownership(&state, &user_id, &payload.wallet_name).await
        .map_err(|e| (
            StatusCode::FORBIDDEN,
            Json(ErrorResponse {
                error: format!("é’±åŒ…éªŒè¯å¤±è´¥: {}", e),
                code: "WALLET_ACCESS_DENIED".to_string(),
                details: None,
            }),
        ))?;
    
    // ==================== æ­¥éª¤ 3: éªŒè¯è¾“å…¥å‚æ•° ====================
    validate_wallet_address(&payload.to_address)?;
    validate_amount(&payload.amount)?;
    validate_network(&payload.network)?;
    
    // ==================== æ­¥éª¤ 4: é€Ÿç‡é™åˆ¶æ£€æŸ¥ ====================
    if !state.rate_limiter.allow() {
        return Err((
            StatusCode::TOO_MANY_REQUESTS,
            Json(ErrorResponse {
                error: "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•".to_string(),
                code: "RATE_LIMIT_EXCEEDED".to_string(),
                details: None,
            }),
        ));
    }
    
    // ==================== æ­¥éª¤ 5: å‘é€äº¤æ˜“ ====================
    let tx_hash = match payload.network.as_str() {
        "ethereum" | "polygon" | "bsc" => {
            // Ethereum å…¼å®¹é“¾
            state.wallet_manager
                .send_eth_transaction(
                    &payload.wallet_name,
                    &payload.to_address,
                    &payload.amount,
                    &payload.network,
                )
                .await
                .map_err(|e| {
                    error!("å‘é€äº¤æ˜“å¤±è´¥: {}", e);
                    (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        Json(ErrorResponse {
                            error: "äº¤æ˜“å‘é€å¤±è´¥".to_string(),
                            code: "TX_SEND_FAILED".to_string(),
                            details: Some(serde_json::json!({ "error": e.to_string() })),
                        }),
                    )
                })?
        }
        "bitcoin" => {
            // Bitcoin
            todo!("Bitcoin äº¤æ˜“å®ç°")
        }
        _ => {
            return Err((
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("ä¸æ”¯æŒçš„ç½‘ç»œ: {}", payload.network),
                    code: "UNSUPPORTED_NETWORK".to_string(),
                    details: None,
                }),
            ));
        }
    };
    
    // ==================== æ­¥éª¤ 6: ç”ŸæˆåŒºå—æµè§ˆå™¨é“¾æ¥ ====================
    let explorer_url = match payload.network.as_str() {
        "ethereum" => format!("https://etherscan.io/tx/{}", tx_hash),
        "polygon" => format!("https://polygonscan.com/tx/{}", tx_hash),
        "bsc" => format!("https://bscscan.com/tx/{}", tx_hash),
        _ => format!("https://example.com/tx/{}", tx_hash),
    };
    
    // ==================== æ­¥éª¤ 7: è®°å½•å®¡è®¡æ—¥å¿— ====================
    info!(
        "äº¤æ˜“å·²å‘é€ | ç”¨æˆ·: {} | é’±åŒ…: {} | äº¤æ˜“å“ˆå¸Œ: {} | ç½‘ç»œ: {}",
        user_id, payload.wallet_name, tx_hash, payload.network
    );
    
    // ==================== æ­¥éª¤ 8: è¿”å›å“åº” ====================
    Ok(Json(SendTransactionResponse {
        tx_hash: tx_hash.clone(),
        network: payload.network.clone(),
        status: "pending".to_string(),
        explorer_url,
    }))
}
```

#### æ­¥éª¤ 3: æ³¨å†Œè·¯ç”±

```rust
// src/api/server.rs

impl WalletServer {
    pub async fn create_router(self) -> Router {
        // ...å…¶ä»–è·¯ç”±...
        
        let router = Router::new()
            // æ·»åŠ æ–°è·¯ç”±
            .route("/api/transactions/send", post(handlers::send_transaction))
            .route("/api/transactions/:tx_hash/status", get(handlers::get_transaction_status))
            // ...
            .layer(/* ä¸­é—´ä»¶ */)
            .with_state(Arc::new(self));
        
        router
    }
}
```

### 2. ä¸­é—´ä»¶å¼€å‘

#### è®¤è¯ä¸­é—´ä»¶

```rust
// src/api/middleware/auth.rs

use axum::{
    extract::State,
    http::{HeaderMap, Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn auth_middleware<B>(
    State(state): State<Arc<WalletServer>>,
    headers: HeaderMap,
    request: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    // 1. æå– Token
    let token = headers
        .get("Authorization")
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.strip_prefix("Bearer "))
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // 2. éªŒè¯ Token
    let user_id = state.session_store
        .validate_token(token)
        .await
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    // 3. å°† user_id é™„åŠ åˆ°è¯·æ±‚æ‰©å±•
    let mut request = request;
    request.extensions_mut().insert(user_id);
    
    // 4. ç»§ç»­å¤„ç†è¯·æ±‚
    Ok(next.run(request).await)
}
```

#### æ—¥å¿—ä¸­é—´ä»¶

```rust
// src/api/middleware/logging.rs

use axum::{
    body::Body,
    http::{Request, Response},
    middleware::Next,
};
use tracing::info;
use std::time::Instant;

pub async fn logging_middleware(
    request: Request<Body>,
    next: Next<Body>,
) -> Response<Body> {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let start = Instant::now();
    
    // æ‰§è¡Œè¯·æ±‚
    let response = next.run(request).await;
    
    // è®°å½•æ—¥å¿—
    let duration = start.elapsed();
    let status = response.status();
    
    info!(
        "{} {} -> {} in {:?}",
        method, uri, status, duration
    );
    
    response
}
```

---

## æ•°æ®åº“è®¾è®¡

### 1. ç”¨æˆ·è¡¨ (users)

```sql
-- migrations/users/001_create_users_table.sql

CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,                  -- UUID
    email TEXT UNIQUE NOT NULL,           -- ç”¨æˆ·é‚®ç®±
    username TEXT,                        -- ç”¨æˆ·å (å¯é€‰)
    password_hash TEXT NOT NULL,          -- Argon2id å¯†ç å“ˆå¸Œ
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_login_at DATETIME,
    is_active BOOLEAN DEFAULT 1,          -- è´¦æˆ·æ˜¯å¦æ¿€æ´»
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until DATETIME                 -- è´¦æˆ·é”å®šæˆªæ­¢æ—¶é—´
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

### 2. ç”¨æˆ·é’±åŒ…å…³è”è¡¨ (user_wallets)

```sql
CREATE TABLE IF NOT EXISTS user_wallets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,                -- ç”¨æˆ· ID (å¤–é”®)
    wallet_name TEXT NOT NULL,            -- é’±åŒ…åç§°
    wallet_address TEXT NOT NULL,         -- é’±åŒ…åœ°å€ (å…¬é’¥)
    wallet_type TEXT DEFAULT 'standard',  -- é’±åŒ…ç±»å‹: standard, multisig, hardware
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, wallet_name),         -- åŒä¸€ç”¨æˆ·é’±åŒ…åç§°å”¯ä¸€
    FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_user_wallets_user_id ON user_wallets(user_id);
CREATE INDEX idx_user_wallets_address ON user_wallets(wallet_address);
```

### 3. æ•°æ®åº“æ“ä½œç¤ºä¾‹

```rust
// src/api/user_db.rs

impl UserDatabase {
    /// åˆ›å»ºç”¨æˆ·
    pub async fn create_user(&self, email: &str, password: &str) -> Result<User> {
        // 1. å“ˆå¸Œå¯†ç 
        let password_hash = Self::hash_password(password)?;
        
        // 2. ç”Ÿæˆ UUID
        let user_id = Uuid::new_v4().to_string();
        
        // 3. æ’å…¥æ•°æ®åº“
        sqlx::query(
            "INSERT INTO users (id, email, password_hash, created_at) 
             VALUES (?, ?, ?, ?)"
        )
        .bind(&user_id)
        .bind(email)
        .bind(&password_hash)
        .bind(Utc::now())
        .execute(&self.pool)
        .await?;
        
        // 4. è¿”å›ç”¨æˆ·å¯¹è±¡
        Ok(User {
            id: user_id,
            email: email.to_string(),
            username: None,
            created_at: Utc::now(),
            last_login_at: None,
            is_active: true,
        })
    }
    
    /// éªŒè¯å¯†ç 
    pub async fn verify_password(&self, email: &str, password: &str) -> Result<bool> {
        // 1. æŸ¥è¯¢å¯†ç å“ˆå¸Œ
        let password_hash: String = sqlx::query_scalar(
            "SELECT password_hash FROM users WHERE email = ?"
        )
        .bind(email)
        .fetch_one(&self.pool)
        .await?;
        
        // 2. éªŒè¯å¯†ç 
        use argon2::{Argon2, PasswordHash, PasswordVerifier};
        
        let parsed_hash = PasswordHash::new(&password_hash)?;
        let valid = Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .is_ok();
        
        Ok(valid)
    }
    
    /// é“¾æ¥é’±åŒ…åˆ°ç”¨æˆ·
    pub async fn link_wallet(
        &self,
        user_id: &str,
        wallet_name: &str,
        wallet_address: &str,
        wallet_type: Option<&str>,
    ) -> Result<()> {
        sqlx::query(
            "INSERT INTO user_wallets (user_id, wallet_name, wallet_address, wallet_type)
             VALUES (?, ?, ?, ?)"
        )
        .bind(user_id)
        .bind(wallet_name)
        .bind(wallet_address)
        .bind(wallet_type.unwrap_or("standard"))
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    /// è·å–ç”¨æˆ·çš„æ‰€æœ‰é’±åŒ…
    pub async fn get_user_wallets(&self, user_id: &str) -> Result<Vec<WalletInfo>> {
        let wallets = sqlx::query_as::<_, WalletInfo>(
            "SELECT wallet_name AS name, wallet_address AS address, 
                    wallet_type, created_at 
             FROM user_wallets 
             WHERE user_id = ? 
             ORDER BY created_at DESC"
        )
        .bind(user_id)
        .fetch_all(&self.pool)
        .await?;
        
        Ok(wallets)
    }
}
```

---

## å®‰å…¨æœ€ä½³å®è·µ

### 1. å¯†ç å®‰å…¨

```rust
// src/security/password_validator.rs

pub struct PasswordValidator {
    min_length: usize,
    require_uppercase: bool,
    require_lowercase: bool,
    require_digit: bool,
    require_special: bool,
}

impl PasswordValidator {
    pub fn validate(&self, password: &str) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();
        
        // é•¿åº¦æ£€æŸ¥
        if password.len() < self.min_length {
            errors.push(format!("å¯†ç é•¿åº¦è‡³å°‘ {} ä¸ªå­—ç¬¦", self.min_length));
        }
        
        // å¤§å†™å­—æ¯æ£€æŸ¥
        if self.require_uppercase && !password.chars().any(|c| c.is_uppercase()) {
            errors.push("å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªå¤§å†™å­—æ¯".to_string());
        }
        
        // å°å†™å­—æ¯æ£€æŸ¥
        if self.require_lowercase && !password.chars().any(|c| c.is_lowercase()) {
            errors.push("å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªå°å†™å­—æ¯".to_string());
        }
        
        // æ•°å­—æ£€æŸ¥
        if self.require_digit && !password.chars().any(|c| c.is_ascii_digit()) {
            errors.push("å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªæ•°å­—".to_string());
        }
        
        // ç‰¹æ®Šå­—ç¬¦æ£€æŸ¥
        if self.require_special && !password.chars().any(|c| "!@#$%^&*()_+-=[]{}|;:,.<>?".contains(c)) {
            errors.push("å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦".to_string());
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

// ä½¿ç”¨ Argon2id å“ˆå¸Œå¯†ç 
pub fn hash_password(password: &str) -> Result<String> {
    use argon2::{
        password_hash::{rand_core::OsRng, PasswordHasher, SaltString},
        Argon2,
    };
    
    let salt = SaltString::generate(&mut OsRng);
    
    // Argon2id é…ç½® (OWASP æ¨è)
    let argon2 = Argon2::default();
    
    let password_hash = argon2
        .hash_password(password.as_bytes(), &salt)
        .map_err(|e| anyhow::anyhow!("å¯†ç å“ˆå¸Œå¤±è´¥: {}", e))?
        .to_string();
    
    Ok(password_hash)
}
```

### 2. å†…å­˜å®‰å…¨

```rust
// src/security/memory_protection.rs

use zeroize::{Zeroize, Zeroizing};

/// æ•æ„Ÿæ•°æ®åŒ…è£…å™¨ (è‡ªåŠ¨æ“¦é™¤)
pub struct SecretVec(Zeroizing<Vec<u8>>);

impl SecretVec {
    pub fn new(data: Vec<u8>) -> Self {
        Self(Zeroizing::new(data))
    }
    
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

impl Drop for SecretVec {
    fn drop(&mut self) {
        // Zeroizing ä¼šè‡ªåŠ¨æ“¦é™¤å†…å­˜
        tracing::debug!("SecretVec å·²è¢«å®‰å…¨æ“¦é™¤");
    }
}

/// é”å®šå†…å­˜é¡µ (é˜²æ­¢äº¤æ¢åˆ°ç£ç›˜)
pub fn lock_memory(data: &[u8]) -> Result<()> {
    #[cfg(target_os = "linux")]
    {
        use libc::{mlock, ENOMEM};
        
        let result = unsafe {
            mlock(data.as_ptr() as *const _, data.len())
        };
        
        if result != 0 {
            let error = std::io::Error::last_os_error();
            if error.raw_os_error() == Some(ENOMEM) {
                return Err(anyhow::anyhow!("å†…å­˜é”å®šå¤±è´¥: è¶…è¿‡ç³»ç»Ÿé™åˆ¶"));
            }
            return Err(anyhow::anyhow!("å†…å­˜é”å®šå¤±è´¥: {}", error));
        }
    }
    
    #[cfg(target_os = "windows")]
    {
        use winapi::um::memoryapi::VirtualLock;
        
        let result = unsafe {
            VirtualLock(data.as_ptr() as *mut _, data.len())
        };
        
        if result == 0 {
            return Err(anyhow::anyhow!("å†…å­˜é”å®šå¤±è´¥: {}", std::io::Error::last_os_error()));
        }
    }
    
    Ok(())
}
```

### 3. é˜²æ­¢æ—¶åºæ”»å‡»

```rust
// src/security/constant_time.rs

use subtle::ConstantTimeEq;

/// å¸¸é‡æ—¶é—´æ¯”è¾ƒ (é˜²æ­¢æ—¶åºæ”»å‡»)
pub fn constant_time_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    
    a.ct_eq(b).into()
}

// ä½¿ç”¨ç¤ºä¾‹
fn verify_hmac(message: &[u8], expected_hmac: &[u8], key: &[u8]) -> bool {
    use hmac::{Hmac, Mac};
    use sha2::Sha256;
    
    let mut mac = Hmac::<Sha256>::new_from_slice(key).unwrap();
    mac.update(message);
    let computed_hmac = mac.finalize().into_bytes();
    
    // âœ… ä½¿ç”¨å¸¸é‡æ—¶é—´æ¯”è¾ƒ
    constant_time_compare(&computed_hmac, expected_hmac)
}
```

---

## æµ‹è¯•æŒ‡å—

### 1. å•å…ƒæµ‹è¯•

```rust
// tests/wallet_manager_tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::config::WalletConfig;
    use crate::core::wallet_manager::WalletManager;
    
    /// æµ‹è¯•é’±åŒ…åˆ›å»ºæˆåŠŸ
    #[tokio::test]
    async fn test_create_wallet_success() {
        // Arrange
        let config = WalletConfig::default();
        let manager = WalletManager::new(&config).await.unwrap();
        
        // Act
        let result = manager.create_wallet("test_wallet", "StrongPassword123!", false).await;
        
        // Assert
        assert!(result.is_ok());
        
        // éªŒè¯é’±åŒ…å·²åˆ›å»º
        let wallets = manager.list_wallets().await.unwrap();
        assert_eq!(wallets.len(), 1);
        assert_eq!(wallets[0].name, "test_wallet");
    }
    
    /// æµ‹è¯•é‡å¤åˆ›å»ºé’±åŒ…å¤±è´¥
    #[tokio::test]
    async fn test_create_wallet_duplicate() {
        // Arrange
        let config = WalletConfig::default();
        let manager = WalletManager::new(&config).await.unwrap();
        manager.create_wallet("test", "pass", false).await.unwrap();
        
        // Act
        let result = manager.create_wallet("test", "pass", false).await;
        
        // Assert
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), WalletError::ValidationError(_)));
    }
    
    /// æµ‹è¯•é’±åŒ…åˆ é™¤
    #[tokio::test]
    async fn test_delete_wallet() {
        // Arrange
        let config = WalletConfig::default();
        let manager = WalletManager::new(&config).await.unwrap();
        manager.create_wallet("test", "pass", false).await.unwrap();
        
        // Act
        let result = manager.delete_wallet("test").await;
        
        // Assert
        assert!(result.is_ok());
        assert_eq!(manager.list_wallets().await.unwrap().len(), 0);
    }
}
```

### 2. é›†æˆæµ‹è¯•

```rust
// tests/api_server_tests.rs

use axum_test::TestServer;
use serde_json::json;

#[tokio::test]
async fn test_register_and_login() {
    // 1. å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    let server = TestServer::new(create_test_app().await).unwrap();
    
    // 2. æ³¨å†Œç”¨æˆ·
    let register_response = server
        .post("/api/auth/register")
        .json(&json!({
            "email": "test@example.com",
            "password": "Test@123456"
        }))
        .await;
    
    assert_eq!(register_response.status_code(), 200);
    let register_body: serde_json::Value = register_response.json();
    assert!(register_body["access_token"].is_string());
    
    // 3. ç™»å½•ç”¨æˆ·
    let login_response = server
        .post("/api/auth/login")
        .json(&json!({
            "email": "test@example.com",
            "password": "Test@123456"
        }))
        .await;
    
    assert_eq!(login_response.status_code(), 200);
    let login_body: serde_json::Value = login_response.json();
    assert!(login_body["access_token"].is_string());
    
    // 4. åˆ›å»ºé’±åŒ… (éœ€è¦è®¤è¯)
    let token = login_body["access_token"].as_str().unwrap();
    let create_wallet_response = server
        .post("/api/wallets")
        .add_header("Authorization", format!("Bearer {}", token))
        .json(&json!({
            "name": "my_wallet",
            "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb9",
            "wallet_type": "standard"
        }))
        .await;
    
    assert_eq!(create_wallet_response.status_code(), 200);
}
```

### 3. æ€§èƒ½æµ‹è¯•

```rust
// benches/crypto_performance.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use defi_hot_wallet::crypto::KeyDerivation;

fn bench_pbkdf2(c: &mut Criterion) {
    let kdf = KeyDerivation::pbkdf2(100_000);
    let password = b"test_password";
    let salt = b"test_salt_32_bytes_long_enough!";
    
    c.bench_function("pbkdf2_100k", |b| {
        b.iter(|| {
            kdf.derive_key(
                black_box(password),
                black_box(salt),
                black_box(32),
            )
        });
    });
}

criterion_group!(benches, bench_pbkdf2);
criterion_main!(benches);
```

### 4. è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_create_wallet

# è¿è¡Œé›†æˆæµ‹è¯•
cargo test --test api_server_tests

# è¿è¡Œæ€§èƒ½æµ‹è¯•
cargo bench

# ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
cargo tarpaulin --out Html --output-dir target/coverage
```

---

## éƒ¨ç½²æŒ‡å—

### 1. ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

#### ç¯å¢ƒå‡†å¤‡

```bash
# 1. æ›´æ–°ç³»ç»Ÿ
sudo apt update && sudo apt upgrade -y

# 2. å®‰è£…ä¾èµ–
sudo apt install -y build-essential pkg-config libssl-dev sqlite3

# 3. å®‰è£… Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# 4. å…‹éš†é¡¹ç›®
git clone https://github.com/DarkCrab-Rust/Rust-Blockchain-Secure-Wallet.git
cd Rust-Blockchain-Secure-Wallet

# 5. é…ç½®ç¯å¢ƒå˜é‡
cp env.example.txt .env
nano .env  # ç¼–è¾‘é…ç½®

# 6. æ„å»ºç”Ÿäº§ç‰ˆæœ¬
cargo build --release --features "all-chains"

# 7. è¿è¡Œæ•°æ®åº“è¿ç§»
sqlite3 users.db < migrations/users/001_create_users_table.sql

# 8. å¯åŠ¨æœåŠ¡
./target/release/hot_wallet server --port 8080
```

#### Systemd æœåŠ¡é…ç½®

```ini
# /etc/systemd/system/wallet-backend.service

[Unit]
Description=Rust Blockchain Wallet Backend
After=network.target

[Service]
Type=simple
User=wallet
Group=wallet
WorkingDirectory=/opt/wallet-backend
EnvironmentFile=/opt/wallet-backend/.env
ExecStart=/opt/wallet-backend/target/release/hot_wallet server --port 8080
Restart=on-failure
RestartSec=5s

# å®‰å…¨é™åˆ¶
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/wallet-backend/data /opt/wallet-backend/logs

[Install]
WantedBy=multi-user.target
```

```bash
# å¯ç”¨å¹¶å¯åŠ¨æœåŠ¡
sudo systemctl daemon-reload
sudo systemctl enable wallet-backend
sudo systemctl start wallet-backend

# æŸ¥çœ‹çŠ¶æ€
sudo systemctl status wallet-backend

# æŸ¥çœ‹æ—¥å¿—
sudo journalctl -u wallet-backend -f
```

### 2. Docker éƒ¨ç½²

```bash
# æ„å»ºé•œåƒ
docker build -t wallet-backend:latest .

# è¿è¡Œå®¹å™¨
docker run -d \
  --name wallet-backend \
  -p 8080:8080 \
  -v $(pwd)/data:/app/data \
  -v $(pwd)/logs:/app/logs \
  --env-file .env \
  --restart unless-stopped \
  wallet-backend:latest

# æŸ¥çœ‹æ—¥å¿—
docker logs -f wallet-backend
```

### 3. NGINX åå‘ä»£ç†

```nginx
# /etc/nginx/sites-available/wallet-backend

upstream wallet_backend {
    server 127.0.0.1:8080;
    # å¦‚æœæœ‰å¤šä¸ªåç«¯å®ä¾‹
    # server 127.0.0.1:8081;
    # server 127.0.0.1:8082;
}

server {
    listen 80;
    server_name api.yourwallet.com;
    
    # HTTP é‡å®šå‘åˆ° HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.yourwallet.com;
    
    # SSL è¯ä¹¦
    ssl_certificate /etc/letsencrypt/live/api.yourwallet.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.yourwallet.com/privkey.pem;
    
    # SSL é…ç½®
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # å®‰å…¨å¤´
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # åå‘ä»£ç†
    location / {
        proxy_pass http://wallet_backend;
        proxy_http_version 1.1;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # è¶…æ—¶é…ç½®
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # ç¼“å†²é…ç½®
        proxy_buffering off;
    }
    
    # é€Ÿç‡é™åˆ¶
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    limit_req zone=api_limit burst=20;
}
```

---

## å¸¸è§é—®é¢˜

### 1. ç¼–è¯‘é”™è¯¯

**é—®é¢˜**: `error: linking with 'cc' failed`

**è§£å†³æ–¹æ¡ˆ**:
```bash
# Ubuntu/Debian
sudo apt install build-essential pkg-config libssl-dev

# macOS
xcode-select --install
```

---

### 2. æ•°æ®åº“è¿æ¥å¤±è´¥

**é—®é¢˜**: `Failed to connect to users database`

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ£€æŸ¥æ•°æ®åº“æ–‡ä»¶æƒé™
ls -la users.db

# ç¡®ä¿æ•°æ®åº“ç›®å½•å­˜åœ¨
mkdir -p data

# é‡æ–°è¿è¡Œè¿ç§»
sqlite3 users.db < migrations/users/001_create_users_table.sql
```

---

### 3. RPC è¿æ¥è¶…æ—¶

**é—®é¢˜**: `Failed to get chain ID from https://eth.llamarpc.com`

**è§£å†³æ–¹æ¡ˆ**:
```bash
# 1. æ£€æŸ¥ç½‘ç»œè¿æ¥
curl -v https://eth.llamarpc.com

# 2. æ›´æ¢ RPC ç«¯ç‚¹
# åœ¨ .env ä¸­è®¾ç½®:
ETHEREUM_RPC=https://eth-mainnet.alchemyapi.io/v2/YOUR-KEY

# 3. é…ç½®ä»£ç† (å¦‚æœéœ€è¦)
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“ä¼˜åŒ–

```rust
// ä½¿ç”¨è¿æ¥æ± 
let pool = SqlitePoolOptions::new()
    .max_connections(10)  // å¢åŠ æœ€å¤§è¿æ¥æ•°
    .min_connections(2)   // ä¿æŒæœ€å°è¿æ¥æ•°
    .acquire_timeout(Duration::from_secs(5))
    .connect(&database_url)
    .await?;

// å¯ç”¨ WAL æ¨¡å¼ (æé«˜å¹¶å‘æ€§èƒ½)
sqlx::query("PRAGMA journal_mode=WAL")
    .execute(&pool)
    .await?;
```

### 2. ç¼“å­˜ç­–ç•¥

```rust
use std::sync::Arc;
use parking_lot::RwLock;
use std::collections::HashMap;

pub struct BalanceCache {
    cache: Arc<RwLock<HashMap<String, (String, Instant)>>>,
    ttl: Duration,
}

impl BalanceCache {
    pub fn get(&self, address: &str) -> Option<String> {
        let cache = self.cache.read();
        cache.get(address).and_then(|(balance, timestamp)| {
            if timestamp.elapsed() < self.ttl {
                Some(balance.clone())
            } else {
                None
            }
        })
    }
    
    pub fn set(&self, address: String, balance: String) {
        let mut cache = self.cache.write();
        cache.insert(address, (balance, Instant::now()));
    }
}
```

### 3. å¼‚æ­¥ä¼˜åŒ–

```rust
// å¹¶è¡ŒæŸ¥è¯¢å¤šä¸ªåœ°å€çš„ä½™é¢
pub async fn get_balances_parallel(
    &self,
    addresses: Vec<String>,
) -> Result<Vec<(String, String)>> {
    use futures::future::join_all;
    
    let futures = addresses.into_iter().map(|addr| {
        let client = self.client.clone();
        async move {
            let balance = client.get_balance(&addr).await?;
            Ok::<_, WalletError>((addr, balance))
        }
    });
    
    let results = join_all(futures).await;
    results.into_iter().collect()
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº† Rust åŒºå—é“¾å®‰å…¨é’±åŒ…çš„å®Œæ•´å¼€å‘æŒ‡å—ï¼Œæ¶µç›–ï¼š

âœ… **ç¯å¢ƒæ­å»º**: å¼€å‘å·¥å…·ã€ä¾èµ–å®‰è£…ã€IDE é…ç½®  
âœ… **æ ¸å¿ƒå®ç°**: é’±åŒ…åˆ›å»ºã€äº¤æ˜“ç­¾åã€è·¨é“¾æ¡¥æ¥  
âœ… **API å¼€å‘**: è·¯ç”±ã€ä¸­é—´ä»¶ã€é”™è¯¯å¤„ç†  
âœ… **æ•°æ®åº“è®¾è®¡**: è¡¨ç»“æ„ã€ç´¢å¼•ã€äº‹åŠ¡  
âœ… **å®‰å…¨å®è·µ**: å¯†ç å®‰å…¨ã€å†…å­˜ä¿æŠ¤ã€é˜²å¾¡æœºåˆ¶  
âœ… **æµ‹è¯•æŒ‡å—**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•  
âœ… **éƒ¨ç½²æ–¹æ¡ˆ**: ç”Ÿäº§éƒ¨ç½²ã€Dockerã€NGINX é…ç½®  

---

**æœ€åæ›´æ–°**: 2024-11-13  
**ç»´æŠ¤è€…**: DarkCrab-Rust  
**è®¸å¯è¯**: MIT OR Apache-2.0  
**è”ç³»æ–¹å¼**: https://github.com/DarkCrab-Rust/Rust-Blockchain-Secure-Wallet

